{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>This is the official documentation page for the emulation project of the mechanical calculator Brunsviga 13 RK from the 1950s. The goal of this page is to provide explanatory resource about the usage and behavior of the web based simulation.</p>"},{"location":"#demonstration","title":"Demonstration","text":"<p>The most recent release of the simulation is hosted with GitHub Pages.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>The simulation requires a relatively recent browser version that is compliant to the ES2020 specification and supports WebGL 2.0. Most up-to-date browsers based on Firefox or Chromium should work just fine.</p>"},{"location":"build/","title":"Build &amp; Run","text":"<p>This chapter explains the process of building and deployment of the emulator software. First, let's discuss the core architecture of the software. The emulator is a web application written in Typescript that uses various frameworks to achieve state managements, 3d rendering, icons and widgets. React is the core component that manages states and is responsible for client side rendering. Widgets are based on MUI and 3d rendering is achieved through three.js which utilizes WebGL under the hood.</p> <p>Info</p> <p>The emulator relies soley on client side rendering. For this reason only a file server is required for deployments.</p>"},{"location":"build/#building-locally","title":"Building locally","text":"<p>Vite is used as the build system and packages are managed by <code>npm</code>. Before building the application make sure to install all required dependencies which are specified in the <code>package.json</code> file. In order to perform a clean installation of the dependencies run:</p> <pre><code>npm ci\n</code></pre> <p>This will create a folder <code>node_modules</code> and download all dependencies into it. Afterward we can start building the application by running:</p> <pre><code>npm run build\n</code></pre> <p>The build process will compile the Typescript source into Javascript perform optimizations and simplify the code. The resulting artifacts will be stored in the <code>dist</code> folder. This folder contains all source code and static assets needed to run the application. In order to so start a web server in the <code>dist</code> folder and load the <code>index.html</code> page.</p> <p>Alternatively you can use <code>vite</code> development build to build and run directly by running:</p> <pre><code>npm run dev\n</code></pre> <p>This will start a web server on port <code>5173</code>. This mode is specifically useful for testing as it will live reload the application when the source files change.</p>"},{"location":"build/#oci-container","title":"OCI container","text":"<p>The repository also contains a <code>Dockerfile</code> which is used for each release to build an OCI compatible container image containing the prebuild application and static assets. This image is uploaded to the GitHub container registry. The latest version of the emulator image can be pulled this way:</p> <pre><code>docker pull ghcr.io/brunsviga13rk/emulator:latest\n</code></pre> <p>Info</p> <p>The Dockerfile and container image works with both Docker and Podman. <code>docker</code> can, in all commands in this chapter, be interchanged with <code>podman</code>.</p> <p>You can also build the image yourself locally through docker:</p> <pre><code>docker build --tag brunsviga13rk/emulator:git .\n</code></pre> <p>The docker image used Nginx as static file server and listens by default on port 80. In order to run the container and access the application make sure to bind the containers port 80 to a host port:</p> <pre><code>docker run -p \"8080:80\" ghcr.io/brunsviga13rk/emulator:latest\n</code></pre> <p>Now you can access the application under <code>http://localhost:8080</code></p>"},{"location":"build/#deployment","title":"Deployment","text":"<p>The application can be deployed through any web server capable of serving static files such as: Apache, Nginx, Caddy, ... This allows to deploy the application through GitHub pages which can only server static sites. The demo application running the latest version is available here.</p>"},{"location":"scripting/","title":"Scripting","text":"<p>The simulation offers the option to write custom scripts which can interact dynamically with the 3d visualization of the calculator. The Lua scripting language was chosen due to its lightweight nature, simple syntax and shallow learning curve. Additionally, it is very simple to integrate the language into others while allowing to hide nasty details about the underlying architecture through abstraction.</p>"},{"location":"scripting/#lua-basics","title":"Lua basics","text":"<p>Lua is a simple programming language with an intuitive and easy syntax. It is primarily designed to run on embedded systems which makes lightweight by nature. It integrates nicely with C and can thus be embedded rather nicely into web browser through the usage of Web assembly. The language is dynamically typed and is reasonably fast in execution. This chapter will give a short introduction into the language to get you started with scripting the emulator.</p>"},{"location":"scripting/#limitations","title":"Limitations","text":"<p>Due to the limited interoperability between Typescript and Lua we do not recommend to use Lua built-in await async with custom functions. For more information see the Wasmoon documentation.</p>"},{"location":"scripting/#brunsviga-13-rk-api","title":"Brunsviga 13 RK API","text":"<p>The following is compilation of all the functions provided by the <code>api</code> module used to interact with the 3d visualization. This chapter is structured logically by register interaction and utility functions.</p> <p>The source of the Lua module can be found at: api.lua. For all the given example usages below it is assumed the API has been setup by creating a local reference to the API module:</p> <pre><code>local api = require'api'\n\n-- Do something with the API.\n</code></pre>"},{"location":"scripting/#input-register","title":"Input register","text":""},{"location":"scripting/#set-a-value","title":"Set a value","text":"<p>Sets the input registers to have a specified value. Waits for the animation of the 3d visualization to complete. The input value is saturated towards the minimum and maximum bounds of the input registers value range. No indicator is provided whether the given value is saturated by the underlying API calls. Example usage:</p> <pre><code>-- Load the number 567 to input register.\napi.load(567)\n</code></pre>"},{"location":"scripting/#reset","title":"Reset","text":"<p>Sets the input registers value to zero. Waits for the animation of the 3d visualization to complete. Example usage:</p> <pre><code>api.reset_input()\n</code></pre>"},{"location":"scripting/#get-current-value","title":"Get current value","text":"<p>Returns the current value of the input register as displayed by the sprocket wheel. This function does not account for negative numbers displayed in complement. Returns immediately after retrieving the desired value.</p> <pre><code>local input_register_value = api.get_input()\n</code></pre>"},{"location":"scripting/#counter-register","title":"Counter register","text":""},{"location":"scripting/#reset_1","title":"Reset","text":"<p>Sets the counter registers value to zero. Waits for the animation of the 3d visualization to complete. Example usage:</p> <pre><code>api.reset_counter()\n</code></pre>"},{"location":"scripting/#get-current-value_1","title":"Get current value","text":"<p>Returns the current value of the counter register as displayed by the sprocket wheel. This function does not account for negative numbers displayed in complement. Returns immediately after retrieving the desired value.</p> <pre><code>local counter_register_value = api.get_counter()\n</code></pre>"},{"location":"scripting/#result-register","title":"Result register","text":""},{"location":"scripting/#reset_2","title":"Reset","text":"<p>Sets the result registers value to zero. Waits for the animation of the 3d visualization to complete. Example usage:</p> <pre><code>api.reset_result()\n</code></pre>"},{"location":"scripting/#get-current-value_2","title":"Get current value","text":"<p>Returns the current value of the result register as displayed by the sprocket wheel. This function does not account for negative numbers displayed in complement. Returns immediately after retrieving the desired value.</p> <pre><code>local result_register_value = api.get_result()\n</code></pre>"},{"location":"scripting/#operators","title":"Operators","text":""},{"location":"scripting/#addition","title":"Addition","text":"<p>Performs a single addition. This will cause the operation crank to rotate clock-wise by 360\u00b0. After completing the input registers value will have been added onto the result register. Waits for the animation of the 3d visualization to complete. Example usage:</p> <pre><code>api.add()\n</code></pre>"},{"location":"scripting/#subtraction","title":"Subtraction","text":"<p>Performs a single subtraction. This will cause the operation crank to rotate counter clock-wise by 360\u00b0. After completing the input registers value will have been subtracted from the result register. Waits for the animation of the 3d visualization to complete. Example usage:</p> <pre><code>api.subtract()\n</code></pre>"},{"location":"scripting/#shift-result-register-left","title":"Shift result register left","text":"<p>Shifts the sled housing the result register by one digit to the left. Waits for the animation of the 3d visualization to complete. Example usage: This has the effect of all subsequent arithmetic operations being shifted by one additional digits to the right.</p> <pre><code>api.shift_left()\n</code></pre>"},{"location":"scripting/#shift-result-register-right","title":"Shift result register right","text":"<p>Shifts the sled housing the result register by one digit to the right. Waits for the animation of the 3d visualization to complete. Example usage: This has the effect of all subsequent arithmetic operations being shifted by one additional digits to the left.</p> <pre><code>api.shift_right()\n</code></pre>"},{"location":"scripting/#utilities","title":"Utilities","text":"<p>The following are functions providing quality of life utility functionalities.</p>"},{"location":"scripting/#reset-all-registers","title":"Reset all registers","text":"<p>Sets all three registers of the machine to zero. Waits for the animation of the 3d visualization to complete. Example usage:</p> <pre><code>api.reset()\n</code></pre>"},{"location":"scripting/#typescript-api","title":"Typescript API","text":"<p>The API designed to be used by the end user is not the API interfacing directly with the simulation. Instead, it is a wrapper written in Lua around a class interface written in Typescript. This serves the purpose of only letting the user access a clean language native API with well-defined behavior. It also removes the need to call <code>:await()</code> manually on all the TS API since these are asynchronous by design and waiting for their completion guarantees a functional state.</p> <p>Breaking state</p> <p>It is not recommended to use this API as incorrect usage may lead to a broken state of the 3d visualization. Due to this no documentation for this API is provided on this page.</p> <p>However, the raw typescript API can still be accessed from within Lua. The Module can be accessed by calling the according get function which is defined for the API version:</p> <pre><code>local raw_ts_api = ts_api_get_0_0_2()\n</code></pre>"},{"location":"solver/","title":"Solving calculations","text":"<p>The simulation is capable of generating the steps required for solving a given computation. This chapter gives an introduction to working with the editor for the solver and explains the behavior and capabilities.</p>"},{"location":"solver/#generate-steps","title":"Generate steps","text":"<p>On the right-hand side of the page under the \"SOLVER\" tab a calculation can be entered in a text field (1). Valid calculations use the most commonly used \"infix\" notation which is the natural way we write equations. This means any operation is sandwiched in between its operands. The solver supports these three arithmetic operations: addition, subtraction and multiplication. Additionally, parenthesis are allowed to enforce the evaluation of certain operations before others. Operator precedence is accounted for, in other words multiplication binds stronger than addition and subtraction. Otherwise, calculations are performed from left to right. Examples for correct calculations are:</p> <ul> <li><code>1 + 3 - 4 * 6</code></li> <li><code>(7 - 3) * 9</code></li> <li><code>(2 + 3) * ((78 - 35) - 5)</code></li> </ul> <p>The below screenshot shows the user interface used to input a calculation and compile steps.</p> <p></p> <p>Upon entering the calculation press the button on the right of the text field (2). In case the calculation contains errors a notification message will be shown below. When simulation was able to compute the steps needed to complete the calculation, the necessary steps will be shown in order below.</p> <p>Info</p> <p>The algorithm used to create the steps will generate steps as a human handling the machine would do so. All steps can be performed on the real machine without issues.</p>"},{"location":"solver/#execute-steps","title":"Execute steps","text":"<p>Generated steps can be executed on the 3d visualization. To do this press the blue run button (3). This will start executing the steps in order. The step currently executing is marked with a blue border. When running all steps the \"run\" button turns into the \"stop\" button. This button is colored red and will, when clicked, stop the execution after the current step.</p> <p>Info</p> <p>When Stopping the execution will not directly stop, only when starting a new step the stop will take place. Long-running steps will complete till the end no matter what.</p> <p></p> <p>Besides the run/stop button there two additional buttons. These are used similarly to a software debugger. The middle button toggles pausing the execution. Unlike the stop button this won't stop the execution entirely. Clicking again after pausing will resume execution on the next step. When pausing the execution the next step can be invoked manually by clicking the next or \"jump over\" button on the right.</p> <p>After all steps are completed the result register contains the correct result of the calculation. In case the result is wrong, feel free to create an issue in the emulator repository for the calculation.</p>"},{"location":"solver/#multiplication","title":"Multiplication","text":"<p>The machine is not capable of performing multiplication directly. Luckily any multiplication can be split into a sequence of sums. Take the following example: $$   7 * 4= 28 $$ This simple equation can be rewritten by adding the number \\(7\\) by a total of \\(4\\) times: $$   7 + 7 + 7 + 7 = 28 $$</p>"},{"location":"solver/#available-functions","title":"Available functions","text":""},{"location":"solver/#where-do-magic-numbers-come-from","title":"Where do magic numbers come from?","text":"<p>The solver generates steps the same way a human might use the machine. Unfortunately, due to the design of the machine temporal result yielded by multiplications or additions cannot be saved into any register for later use. This means the solver remembers intermediate results for later use. The intermediate results appear in load operations for input register as \"magic numbers\". However, these are just the results of previous operations that cannot be carried directly into the next operation. Sometimes the solver can optimize the magic numbers by using their value directly in the result register, but this is not always possible. Normally a human might write this intermediate results on a paper for later use.</p>"},{"location":"ui/","title":"User interface","text":""}]}